Часть 4: Теоретические вопросы
Ответьте письменно в файле answers.md (в том же репозитории) на следующие вопросы:

1. В чём основное различие между unittest и pytest?
   unittest — стандартная библиотека Python, основанная на наследовании классов и строго структурированных методах тестов. Требует чёткого соблюдения правил оформления и предоставляет базовые инструменты для тестирования.

class MyTest(unittest.TestCase):
    def test_my_function(self):
        self.assertEqual(my_function(), expected_output)
pytest — внешняя библиотека, предоставляющая гораздо больший набор функциональных возможностей и гибкость. Поддерживает лаконичный и понятный синтаксис тестов, минимизирует шаблонный код и легко интегрируется с дополнительными средствами (фикстуры, параметризация, настройка окружения и многое другое).

def test_my_function():
    assert my_function() == expected_output
    
2. Почему важно использовать автоматические тесты при разработке?
   Автоматические тесты значительно улучшают качество программного обеспечения:
Помогают выявить проблемы на ранних этапах разработки.
Минимизируют риск появления новых ошибок при внесении изменений в код.
Ускоряют разработку за счёт быстрой обратной связи о состоянии системы.
Повышают доверие разработчиков и пользователей к качеству выпускаемого продукта.

3. Какие есть виды ассертов в unittest и pytest?
   В unittest наиболее распространённые ассерты включают:
assertEqual(a, b) — сравнивает равенство двух объектов.
assertAlmostEqual(a, b) — сравнение приближённых значений с плавающей точкой.
assertTrue(x) — проверяет истинность условия.
assertFalse(x) — проверяет ложность условия.
assertIn(item, collection) — проверяет наличие элемента в коллекции.
assertRaises(exception_type) — проверяет возникновение ожидаемого исключения.
  В pytest используется прямой оператор сравнения ==, но дополнительно предоставляются удобные средства для особых случаев:

assert a == b — прямое сравнение значений.
pytest.approx(value) — проверка приблизительного равенства чисел с плавающей точкой.
with pytest.raises(ExceptionType) — контроль возникновения определённого исключения.
Специальные утверждения, предоставляемые сторонними пакетами, такими как pytest-html или pytest-cov.

4. Что делает @pytest.mark.parametrize?
   Этот декоратор предназначен для многократного выполнения одного и того же теста с разным набором входных данных. Вместо написания множества похожих тестов, можно воспользоваться одной универсальной функцией, которую автоматически вызывает pytest с указанными параметрами.Например:

@pytest.mark.parametrize(
    ('a', 'b'), [(1, 2), (-1, -2)]
)
def test_addition(a, b):
    assert add(a, b) == a + b
Здесь один тест будет выполнен дважды: сначала с парами (1, 2), потом с (-1, -2).

5. В каких случаях вы бы предпочли использовать pytest вместо unittest?
  Я бы выбрал pytest в следующих ситуациях:
Когда важен быстрый старт и простота написания тестов без большого количества шаблонного кода.
Необходимость удобной параметризации тестов (используя @pytest.mark.parametrize).
Использование продвинутых средств управления окружением (фикстуры).
Интеграция с обширным набором дополнений (плагины для HTML-отчётов, покрытия кода, параллельного выполнения тестов и многого другого).
Работа над большими проектами, где потребуется высокая гибкость и масштабируемость инфраструктуры тестирования.
